/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import type { IncomingHttpHeaders } from 'http';
import {
  Transport,
  type TransportOptions,
  type TransportRequestParams,
  type TransportRequestOptions,
  type TransportResult,
} from '@elastic/elasticsearch';
import { isUnauthorizedError } from '@kbn/es-errors';
import { IExecutionContext } from '@kbn/core-execution-context-server-internal';
import { InternalUnauthorizedErrorHandler, isRetryResult } from './retry_unauthorized';

type TransportClass = typeof Transport;

export type ErrorHandlerAccessor = () => InternalUnauthorizedErrorHandler;

export const createTransport = ({
  executionContext,
  getUnauthorizedErrorHandler,
}: {
  executionContext?: IExecutionContext;
  getUnauthorizedErrorHandler?: ErrorHandlerAccessor;
}): TransportClass => {
  class KibanaTransport extends Transport {
    private headers: IncomingHttpHeaders = {};

    constructor(options: TransportOptions) {
      const { headers = {}, ...otherOptions } = options;
      super(otherOptions);
      this.headers = headers;
    }

    async request(params: TransportRequestParams, options?: TransportRequestOptions) {
      const opts: TransportRequestOptions = options ? { ...options } : {};
      executionContext?.get()?.incrementCircuitBreaker('requests');
      const requests = executionContext?.get()?.getCircuitBreaker('requests') ?? 0;
      if (requests > 0 && requests % 100 === 0) {
        console.log(
          `CIRCUIT_BREAKER_ERROR: ${requests} requests generated by execution context ${executionContext
            ?.get()
            ?.toString()}`
        );
        // throw new Error('CIRCUIT_BREAKER_ERROR: too many requests');
      }
      const opaqueId = executionContext?.getAsHeader();
      if (opaqueId && !opts.opaqueId) {
        // rewrites headers['x-opaque-id'] if it presents
        opts.opaqueId = opaqueId;
      }

      // add stored headers to the options
      opts.headers = {
        ...this.headers,
        ...options?.headers,
      };

      try {
        return (await super.request(params, opts)) as TransportResult<any, any>;
      } catch (e) {
        if (isUnauthorizedError(e)) {
          const unauthorizedErrorHandler = getUnauthorizedErrorHandler
            ? getUnauthorizedErrorHandler()
            : undefined;
          if (unauthorizedErrorHandler) {
            const result = await unauthorizedErrorHandler(e);
            if (isRetryResult(result)) {
              this.headers = {
                ...this.headers,
                ...result.authHeaders,
              };
              const retryOpts = { ...opts };
              retryOpts.headers = {
                ...this.headers,
                ...options?.headers,
              };
              return (await super.request(params, retryOpts)) as TransportResult<any, any>;
            }
          }
        }
        throw e;
      }
    }
  }

  return KibanaTransport;
};
